<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Magic Christmas ‚Äì Final Fixed</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

<style>
body { margin:0; overflow:hidden; background:black; font-family:sans-serif }
#canvas-container { width:100%; height:100vh }
#ui-layer {
    position:absolute; bottom:25px; width:100%;
    text-align:center; z-index:10; pointer-events:none
}
button {
    pointer-events:auto;
    padding:14px 50px;
    border-radius:30px;
    font-weight:bold;
    background:#b30000;
    color:white;
    border:2px solid gold;
    cursor:pointer;
}
#camera-preview {
    position:absolute;
    top:15px; right:15px;
    width:120px; height:90px;
    opacity:0.6;
    transform:scaleX(-1);
}
.guide { color:#ccc; margin-bottom:15px; font-size:13px }
</style>
</head>

<body>

<div id="ui-layer">
    <div class="guide">
        ‚úä Fist = Tree | ‚úã Open = Explode | ü§è Pinch = Open Photo | ü´∂ Heart = Love
    </div>
    <button onclick="startSystem()">START MAGIC</button>
</div>

<div id="canvas-container"></div>
<video class="input_video" style="display:none"></video>
<canvas id="camera-preview"></canvas>

<script>
// ===================================================
// CONFIG
// ===================================================
const CONFIG = {
    treeHeight: 70,
    treeRadius: 35,
    goldCount: 1800,
    photoCount: 15
};

let scene, camera, renderer;
let groupGold;
let photoMeshes = [];
let state = "TREE";
let selectedPhoto = null;

// hand + camera
let handX = 0.5, handY = 0.5;
let camYaw = 0, camPitch = 0;

// ===================================================
// LOAD IMAGES
// ===================================================
const loader = new THREE.TextureLoader();
const photoTextures = [];
for (let i = 1; i <= CONFIG.photoCount; i++) {
    photoTextures.push(loader.load(`./image${i}.jpeg`));
}

// ===================================================
// INIT 3D
// ===================================================
function init3D() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0,0,100);

    renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(innerWidth, innerHeight);
    document.getElementById("canvas-container").appendChild(renderer.domElement);

    createTreeParticles();
    createPhotos();
    animate();
}

// ===================================================
// TREE PARTICLES
// ===================================================
function createTreeParticles() {
    const positions = [];

    for (let i=0; i<CONFIG.goldCount; i++) {
        const h = Math.random() * CONFIG.treeHeight;
        const r = (1 - h / CONFIG.treeHeight) * CONFIG.treeRadius * Math.random();
        const a = Math.random() * Math.PI * 2;
        positions.push(
            Math.cos(a) * r,
            h - CONFIG.treeHeight/2,
            Math.sin(a) * r
        );
    }

    const geo = new THREE.BufferGeometry();
    geo.setAttribute("position", new THREE.Float32BufferAttribute(positions,3));
    geo.userData.tree = positions;

    const mat = new THREE.PointsMaterial({
        size:2,
        color:0xFFD700,
        transparent:true,
        blending:THREE.AdditiveBlending
    });

    groupGold = new THREE.Points(geo, mat);
    scene.add(groupGold);
}

// ===================================================
// PHOTOS ON TREE (RANDOM)
// ===================================================
function createPhotos() {
    const geo = new THREE.PlaneGeometry(7,7);
    const borderGeo = new THREE.PlaneGeometry(8,8);
    const borderMat = new THREE.MeshBasicMaterial({ color:0xFFD700 });

    const tree = groupGold.geometry.userData.tree;

    photoTextures.forEach(tex => {
        const mat = new THREE.MeshBasicMaterial({
            map: tex,
            side: THREE.DoubleSide,
            transparent:true
        });

        const mesh = new THREE.Mesh(geo, mat);
        const border = new THREE.Mesh(borderGeo, borderMat);
        border.position.z = -0.1;
        mesh.add(border);

        const i = Math.floor(Math.random() * (tree.length/3)) * 3;
        mesh.userData.treePos = new THREE.Vector3(
            tree[i], tree[i+1], tree[i+2]
        );

        mesh.position.copy(mesh.userData.treePos);
        mesh.scale.set(0,0,0);
        mesh.visible = false;

        scene.add(mesh);
        photoMeshes.push(mesh);
    });
}

// ===================================================
// ANIMATE
// ===================================================
function animate() {
    requestAnimationFrame(animate);

    // 360¬∞ CAMERA CONTROL
    camYaw += (handX - 0.5) * 0.04;
    camPitch += (handY - 0.5) * 0.03;
    camPitch = THREE.MathUtils.clamp(camPitch, -1.2, 1.2);

    camera.position.x = Math.sin(camYaw) * 100;
    camera.position.z = Math.cos(camYaw) * 100;
    camera.position.y = camPitch * 60;
    camera.lookAt(0,0,0);

    // TREE ROTATION
    groupGold.rotation.y += 0.002;

    // PHOTOS
    photoMeshes.forEach(mesh => {
        if (state === "EXPLODE") {
            mesh.visible = true;
            const pos = mesh.userData.treePos.clone();
            pos.applyAxisAngle(new THREE.Vector3(0,1,0), camYaw);
            mesh.position.lerp(pos,0.1);
            mesh.lookAt(camera.position);
            mesh.scale.lerp(new THREE.Vector3(1,1,1),0.1);
        }
        else if (state === "PHOTO" && mesh === selectedPhoto) {
            mesh.position.lerp(new THREE.Vector3(0,0,40),0.1);
            mesh.scale.lerp(new THREE.Vector3(5,5,5),0.1);
        }
        else {
            mesh.scale.lerp(new THREE.Vector3(0,0,0),0.1);
            mesh.visible = false;
        }
    });

    renderer.render(scene,camera);
}

// ===================================================
// HAND TRACKING
// ===================================================
function startSystem() {
    init3D();

    const video = document.querySelector(".input_video");
    const canvas = document.getElementById("camera-preview");
    const ctx = canvas.getContext("2d");

    const hands = new Hands({
        locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
    });

    hands.setOptions({
        maxNumHands: 2,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });

    hands.onResults(res => {
        ctx.drawImage(res.image,0,0,120,90);

        if (!res.multiHandLandmarks.length) {
            state = "TREE";
            return;
        }

        const lm = res.multiHandLandmarks[0];
        handX = lm[9].x;
        handY = lm[9].y;

        const pinch = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
        const open = [8,12,16,20].reduce((s,i)=>s+Math.hypot(lm[i].x-lm[0].x,lm[i].y-lm[0].y),0)/4;

        if (open < 0.25) state="TREE";
        else if (pinch < 0.05) {
            state="PHOTO";
            selectedPhoto = photoMeshes[Math.floor(Math.random()*photoMeshes.length)];
        }
        else state="EXPLODE";
    });

    const cam = new Camera(video,{
        onFrame: async()=>await hands.send({image:video}),
        width:320, height:240
    });
    cam.start();
}

window.addEventListener("resize",()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
});
</script>

</body>
</html>
